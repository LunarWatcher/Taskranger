Import("env")

from sys import platform

def checkSecure(context):
    """
    Checks whether secure_getenv is present or not
    """
    context.Message("Checking secure_getenv... ")

    secureProbe = """
    #define _GNU_SOURCE
    #include <stdlib.h>
    int main() {
        secure_getenv("fakeVar");
    }
    """

    compiled = context.TryCompile(secureProbe, ".cpp")

    context.Result("yes" if compiled else "no")
    return compiled

with env.configure() as config:
    config.test("CheckCXX")
    config.configureFilesystem()

    if platform != "win32":
        if config.test("CheckSecureGetEnv", callback=checkSecure):
            env.define("HAS_SECURE_GETENV")

# Glob in sources
# okay, fine, it's not exactly the prettiest approach, but the other alternatives require implementing
# a recursive glob function, and I have no idea how. Definitely high on the list, in my defense.

sources = env.Glob("taskranger/input/*.cpp")
sources += env.Glob("taskranger/input/operators/*.cpp")
sources += env.Glob("taskranger/commands/*.cpp")
sources += env.Glob("taskranger/util/*.cpp")
sources += env.Glob("taskranger/data/*.cpp")
sources += env.Glob("taskranger/config/*.cpp")

# Link src
env.appendSourcePath("#src/")
env.appendSourcePath("#tabulate/include")


# The executable is named after the program instead of a shorthand function in order to avoid collisions with other todo programs.
# Shell aliases can be manually added if necessary.
lib = env.Library("taskranger", sources)

exeEnv = env.Clone()
exeEnv.appendLibPath("#" + env.getBinPath())
exeEnv.withLibraries("taskranger", append=False)

exe = exeEnv.Program("taskranger", env.Glob("taskranger/*.cpp"))
Default(exe, lib)
